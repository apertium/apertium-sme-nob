Alphabet

%#:0
%# ! Need this, since otherwise #-words not matched by our rule will disappear

%+N
%+A

%+Cmpnd
%+SgCmp      	%+PlCmp
%+SgLeft      	%+PlLeft
%+SgNomCmp   	%+PlNomCmp
%+SgNomLeft  	%+PlNomLeft
%+SgGenCmp   	%+PlGenCmp
%+SgGenLeft  	%+PlGenLeft
%+DefSgGenCmp 	%+DefPlGenCmp

%+Cmpnd:0
%+SgCmp:0    	%+PlCmp:0
%+SgLeft:0    	%+PlLeft:0
%+SgNomCmp:0 	%+PlNomCmp:0
%+SgNomLeft:0  	%+PlNomLeft:0
%+SgGenCmp:0 	%+PlGenCmp:0
%+SgGenLeft:0  	%+PlGenLeft:0
%+DefSgGenCmp:0 %+DefPlGenCmp:0

%+Use/Circ

%+Use/NG:0
%+Use/Ped:0
%+Use/Sub:0
%+Use/Circ:0
%+Use/CircN:0
%+Use/Marg:0
%+Use/NG:0
%+Dial/%-KJ:0
%+Dial/%-GG:0
%+Dial/%-GS:0
;


Sets

Cmptag = 
%+Cmpnd
%+SgCmp      	%+PlCmp
%+SgLeft      	%+PlLeft
%+SgNomCmp   	%+PlNomCmp
%+SgNomLeft  	%+PlNomLeft
%+SgGenCmp   	%+PlGenCmp
%+SgGenLeft  	%+PlGenLeft
%+DefSgGenCmp 	%+DefPlGenCmp
;

KeepCmpAfter =
%+N
%+A
;

HashPrefix =			! only one I've seen so far
%+Use/Circ
;

Useless =
%+Use/NG
%+Use/Ped	
%+Use/Sub	
%+Use/Circ	
%+Use/CircN	
%+Use/Marg	
%+Use/NG	
%+Dial/%-KJ	
%+Dial/%-GG	
%+Dial/%-GS	
;

Rules 

"#-deletion unless after compounding or prefix tags"
! %#:0 <=> ~ [ Cmptag HashPrefix:? * ] _ ; ! <- this doesn't parse :(
%#:0 <=> \[ Cmptag | HashPrefix:? ] _ ;  

! After inversion, we get
!   ^sámegiella/sápmi+N+SgGenCmp#giella+N+Sg+Nom/sáme#giella+N+Sg+Nom$
! After this file, we get
!   ^sámegiella/sápmi+N+SgGenCmp#giella+N+Sg+Nom/sámegiella+N+Sg+Nom$
! After substitution/relabelling, we get
!   ^sámegiella/sápmi<N><Sg><Gen><Cmp>+giella<N><Sg><Nom>/sámegiella<N><Sg><Nom>$
! which after pretransfer turns into 
!   ^sápmi<N><Sg><Gen><Cmp>$ ^giella<N><Sg><Nom>$
! or
!   ^sámegiella<N><Sg><Nom>$
! respectively.


"Delete compound tags that weren't followed by an N or A or Use/Sub tag"
! Cmptag:0 <=> ~[ KeepCmpAfter %+Use/Sub:? * ] _ ; ! <- this doesn't parse :(
Cmptag:0 <=> \[ KeepCmpAfter | %+Use/Sub:? ] _ ; 


"Delete Use-tags etc. that we don't use"
Useless:0 <=> _ ; 
! Removing tags with hfst-substitute will give duplicate analyses, so
! we do it here instead

